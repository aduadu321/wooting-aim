/* This is a generated header file providing the common items to everything related to the Analog SDK */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum WootingAnalogResult {
  WootingAnalogResult_Ok = 1,
  /// Item hasn't been initialized
  WootingAnalogResult_UnInitialized = -2000,
  /// No Devices are connected
  WootingAnalogResult_NoDevices = -1999,
  /// Device has been disconnected
  WootingAnalogResult_DeviceDisconnected = -1998,
  /// Generic Failure
  WootingAnalogResult_Failure = -1997,
  /// A given parameter was invalid
  WootingAnalogResult_InvalidArgument = -1996,
  /// No Plugins were found
  WootingAnalogResult_NoPlugins = -1995,
  /// The specified function was not found in the library
  WootingAnalogResult_FunctionNotFound = -1994,
  /// No Keycode mapping to HID was found for the given Keycode
  WootingAnalogResult_NoMapping = -1993,
  /// Indicates that it isn't available on this platform
  WootingAnalogResult_NotAvailable = -1992,
  /// Indicates that the operation that is trying to be used is for an older version
  WootingAnalogResult_IncompatibleVersion = -1991,
  /// Indicates that the Analog SDK could not be found on the system
  WootingAnalogResult_DLLNotFound = -1990,
} WootingAnalogResult;

typedef enum WootingAnalog_DeviceEventType {
  /// Device has been connected
  WootingAnalog_DeviceEventType_Connected = 1,
  /// Device has been disconnected
  WootingAnalog_DeviceEventType_Disconnected = 2,
} WootingAnalog_DeviceEventType;

typedef enum WootingAnalog_KeycodeType {
  /// USB HID Keycodes https://www.usb.org/document-library/hid-usage-tables-112 pg53
  WootingAnalog_KeycodeType_HID = 0,
  /// Scan code set 1
  WootingAnalog_KeycodeType_ScanCode1 = 1,
  /// Windows Virtual Keys
  WootingAnalog_KeycodeType_VirtualKey = 2,
  /// Windows Virtual Keys which are translated to the current keyboard locale
  WootingAnalog_KeycodeType_VirtualKeyTranslate = 3,
} WootingAnalog_KeycodeType;

typedef enum WootingAnalog_DeviceType {
  /// Device is of type Keyboard
  WootingAnalog_DeviceType_Keyboard = 1,
  /// Device is of type Keypad
  WootingAnalog_DeviceType_Keypad = 2,
  /// Device
  WootingAnalog_DeviceType_Other = 3,
} WootingAnalog_DeviceType;

typedef uint64_t WootingAnalog_DeviceID;

/// The core `DeviceInfo` struct which contains all the interesting information
/// for a particular device. This is the version which the consumer of the SDK will receive
/// through the wrapper. This is not for use in the Internal workings of the SDK, that is what
/// DeviceInfo is for
typedef struct WootingAnalog_DeviceInfo_FFI {
  /// Device Vendor ID `vid`
  uint16_t vendor_id;
  /// Device Product ID `pid`
  uint16_t product_id;
  /// Device Manufacturer name
  char *manufacturer_name;
  /// Device name
  char *device_name;
  /// Unique device ID, which should be generated using `generate_device_id`
  WootingAnalog_DeviceID device_id;
  /// Hardware type of the Device see `DeviceType` enum
  WootingAnalog_DeviceType device_type;
} WootingAnalog_DeviceInfo_FFI;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/// Initialises the Analog SDK, this needs to be successfully called before any other functions
/// of the SDK can be called
///
/// # Expected Returns
/// * `ret>=0`: Meaning the SDK initialised successfully and the number indicates the number of devices that were found on plugin initialisation
/// * `NoPlugins`: Meaning that either no plugins were found or some were found but none were successfully initialised
int wooting_analog_initialise(void);

/// Provides the major version of the SDK, a difference in this value to what is expected indicates that
/// there may be some breaking changes that have been made so the SDK should not be attempted to be used
int wooting_analog_version(void);

/// SDK version as a static null-terminated string in SemVer format.
const char *wooting_analog_version_semver(void);

/// Returns a bool indicating if the Analog SDK has been initialised
bool wooting_analog_is_initialised(void);

/// Uninitialises the SDK, returning it to an empty state, similar to how it would be before first initialisation
/// # Expected Returns
/// * `Ok`: Indicates that the SDK was successfully uninitialised
enum WootingAnalogResult wooting_analog_uninitialise(void);

/// Sets the type of Keycodes the Analog SDK will receive (in `read_analog`) and output (in `read_full_buffer`).
///
/// By default, the mode is set to HID
///
/// # Notes
/// * `VirtualKey` and `VirtualKeyTranslate` are only available on Windows
/// * With all modes except `VirtualKeyTranslate`, the key identifier will point to the physical key on the standard layout. i.e. if you ask for the Q key, it will be the key right to tab regardless of the layout you have selected
/// * With `VirtualKeyTranslate`, if you request Q, it will be the key that inputs Q on the current layout, not the key that is Q on the standard layout.
///
/// # Expected Returns
/// * `Ok`: The Keycode mode was changed successfully
/// * `InvalidArgument`: The given `KeycodeType` is not one supported by the SDK
/// * `NotAvailable`: The given `KeycodeType` is present, but not supported on the current platform
/// * `UnInitialized`: The SDK is not initialised
enum WootingAnalogResult wooting_analog_set_keycode_mode(unsigned int mode);

/// Reads the Analog value of the key with identifier `code` from any connected device. The set of key identifiers that is used
/// depends on the Keycode mode set using `wooting_analog_set_mode`.
///
/// # Examples
/// ```ignore
/// wooting_analog_set_mode(KeycodeType::ScanCode1);
/// wooting_analog_read_analog(0x10); //This will get you the value for the key which is Q in the standard US layout (The key just right to tab)
///
/// wooting_analog_set_mode(KeycodeType::VirtualKey); //This will only work on Windows
/// wooting_analog_read_analog(0x51); //This will get you the value for the key that is Q on the standard layout
///
/// wooting_analog_set_mode(KeycodeType::VirtualKeyTranslate);
/// wooting_analog_read_analog(0x51); //This will get you the value for the key that inputs Q on the current layout
/// ```
///
/// # Expected Returns
/// The float return value can be either a 0->1 analog value, or (if <0) is part of the WootingAnalogResult enum, which is how errors are given back on this call.
/// So if the value is below 0, you should cast it as WootingAnalogResult to see what the error is.
/// * `0.0f - 1.0f`: The Analog value of the key with the given id `code`
/// * `WootingAnalogResult::NoMapping`: No keycode mapping was found from the selected mode (set by wooting_analog_set_mode) and HID.
/// * `WootingAnalogResult::UnInitialized`: The SDK is not initialised
/// * `WootingAnalogResult::NoDevices`: There are no connected devices
float wooting_analog_read_analog(unsigned short code);

/// Reads the Analog value of the key with identifier `code` from the device with id `device_id`. The set of key identifiers that is used
/// depends on the Keycode mode set using `wooting_analog_set_mode`.
///
/// The `device_id` can be found through calling `wooting_analog_device_info` and getting the DeviceID from one of the DeviceInfo structs
///
/// # Expected Returns
/// The float return value can be either a 0->1 analog value, or (if <0) is part of the WootingAnalogResult enum, which is how errors are given back on this call.
/// So if the value is below 0, you should cast it as WootingAnalogResult to see what the error is.
/// * `0.0f - 1.0f`: The Analog value of the key with the given id `code` from device with id `device_id`
/// * `WootingAnalogResult::NoMapping`: No keycode mapping was found from the selected mode (set by wooting_analog_set_mode) and HID.
/// * `WootingAnalogResult::UnInitialized`: The SDK is not initialised
/// * `WootingAnalogResult::NoDevices`: There are no connected devices with id `device_id`
float wooting_analog_read_analog_device(unsigned short code,
                                        WootingAnalog_DeviceID device_id);

/// Set the callback which is called when there is a DeviceEvent. Currently these events can either be Disconnected or Connected(Currently not properly implemented).
/// The callback gets given the type of event `DeviceEventType` and a pointer to the DeviceInfo struct that the event applies to
///
/// # Notes
/// * You must copy the DeviceInfo struct or its data if you wish to use it after the callback has completed, as the memory will be freed straight after
/// * The execution of the callback is performed in a separate thread so it is fine to put time consuming code and further SDK calls inside your callback
///
/// # Expected Returns
/// * `Ok`: The callback was set successfully
/// * `UnInitialized`: The SDK is not initialised
enum WootingAnalogResult wooting_analog_set_device_event_cb(void (*cb)(enum WootingAnalog_DeviceEventType,
                                                                       struct WootingAnalog_DeviceInfo_FFI*));

/// Clears the device event callback that has been set
///
/// # Expected Returns
/// * `Ok`: The callback was cleared successfully
/// * `UnInitialized`: The SDK is not initialised
enum WootingAnalogResult wooting_analog_clear_device_event_cb(void);

/// Fills up the given `buffer`(that has length `len`) with pointers to the DeviceInfo structs for all connected devices (as many that can fit in the buffer)
///
/// # Notes
/// * The memory of the returned structs will only be kept until the next call of this function, so if you wish to use any data from them, please copy it or ensure you don't reuse references to old memory after calling this function again.
///
/// # Expected Returns
/// Similar to wooting_analog_read_analog, the errors and returns are encoded into one type. Values >=0 indicate the number of items filled into the buffer, with `<0` being of type WootingAnalogResult
/// * `ret>=0`: The number of connected devices that have been filled into the buffer
/// * `WootingAnalogResult::UnInitialized`: Indicates that the AnalogSDK hasn't been initialised
int wooting_analog_get_connected_devices_info(struct WootingAnalog_DeviceInfo_FFI **buffer,
                                              unsigned int len);

/// Reads all the analog values for pressed keys for all devices and combines their values, filling up `code_buffer` with the
/// keycode identifying the pressed key and fills up `analog_buffer` with the corresponding float analog values. i.e. The analog
/// value for they key at index 0 of code_buffer, is at index 0 of analog_buffer.
///
/// # Notes
/// * `len` is the length of code_buffer & analog_buffer, if the buffers are of unequal length, then pass the lower of the two, as it is the max amount of
/// key & analog value pairs that can be filled in.
/// * The codes that are filled into the `code_buffer` are of the KeycodeType set with wooting_analog_set_mode
/// * If two devices have the same key pressed, the greater value will be given
/// * When a key is released it will be returned with an analog value of 0.0f in the first read_full_buffer call after the key has been released
///
/// # Expected Returns
/// Similar to other functions like `wooting_analog_device_info`, the return value encodes both errors and the return value we want.
/// Where >=0 is the actual return, and <0 should be cast as WootingAnalogResult to find the error.
/// * `>=0` means the value indicates how many keys & analog values have been read into the buffers
/// * `WootingAnalogResult::UnInitialized`: Indicates that the AnalogSDK hasn't been initialised
/// * `WootingAnalogResult::NoDevices`: Indicates no devices are connected
int wooting_analog_read_full_buffer(unsigned short *code_buffer,
                                    float *analog_buffer,
                                    unsigned int len);

/// Reads all the analog values for pressed keys for the device with id `device_id`, filling up `code_buffer` with the
/// keycode identifying the pressed key and fills up `analog_buffer` with the corresponding float analog values. i.e. The analog
/// value for they key at index 0 of code_buffer, is at index 0 of analog_buffer.
///
/// # Notes
/// * `len` is the length of code_buffer & analog_buffer, if the buffers are of unequal length, then pass the lower of the two, as it is the max amount of
/// key & analog value pairs that can be filled in.
/// * The codes that are filled into the `code_buffer` are of the KeycodeType set with wooting_analog_set_mode
/// * When a key is released it will be returned with an analog value of 0.0f in the first read_full_buffer call after the key has been released
///
/// # Expected Returns
/// Similar to other functions like `wooting_analog_device_info`, the return value encodes both errors and the return value we want.
/// Where >=0 is the actual return, and <0 should be cast as WootingAnalogResult to find the error.
/// * `>=0` means the value indicates how many keys & analog values have been read into the buffers
/// * `WootingAnalogResult::UnInitialized`: Indicates that the AnalogSDK hasn't been initialised
/// * `WootingAnalogResult::NoDevices`: Indicates the device with id `device_id` is not connected
int wooting_analog_read_full_buffer_device(unsigned short *code_buffer,
                                           float *analog_buffer,
                                           unsigned int len,
                                           WootingAnalog_DeviceID device_id);

bool wooting_analog_using_sys(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
